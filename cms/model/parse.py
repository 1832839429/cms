# functions for file-parsing (et al) from JV demographic modelling pipeline as part of CMS 2.0.
# last updated 06.29.16 	vitti@broadinstitute.org
## {{POP GEN DATA --> DEM MODEL}}
## this script contains functions to facilitate parsing files, esp. output generated by Univa Grid Engine (UGER) at sequential steps of the pipeline.
## last updated: 06.04.16 	vitti@broadinstitute.org
## JV: MORE WORK NEEDED HERE; esp, checkFailed

import params
import subprocess
import math
import sys
import os

###########################
## DEFINE BINS FOR DISTS ##
###########################
mafcutoffdprime = .2
nhist = 6
nphysdisthist, ngendisthist = 14, 17


###############
## VERSATILE ##
###############
def givecommand(commandstr):
	commands = commandstr.split(' ')
	subprocess.check_output(commands)
def readlines(openfile, numlines):
	for i in range(numlines):
		line = openfile.readline()
	return line
def checkFailed(errorfilename):
	#ad hoc 
	failed = False
	if not os.path.isfile(errorfilename):
		return True
	openfile = open(errorfilename, 'r')
	for line in openfile:
		entries = line.split()
		#print entries
		if "fault" in entries or "Traceback" in entries: #if C or python failed
			failed = True
			return failed
	openfile.close()
	return failed

###################
## UGER PIPELINE ##
###################
def readParameterValues(openfile, numParams):
	paramVals = []
	while len(paramVals) < numParams:
		line = openfile.readline()
		if not line:
			break
		entries = line.split()
		if ']' in entries:
			entries.remove(']')
		if '[' in entries:
			entries.remove('[')
		for i in range(len(entries)):
			item = entries[i]
			if ']' in item:
				entries[i] = item.strip(']')
			if '[' in item:
				entries[i] = item.strip('[')
		paramVals.extend(map(float,entries))
	return paramVals #np.array(paramVals)
def readGlobalArgfile(filename):
	openfile = open(filename, 'r')
	gridname = openfile.readline().strip('\n')
	errorstring = openfile.readline()
	errorcomponents = errorstring.split('_')[:-1]
	stats, pops = [], []
	for component in errorcomponents:
		if component.isdigit():
			pops.append(int(component))
		else:
			stats.append(component)
	keys = eval(openfile.readline())
	indices = eval(openfile.readline())
	nreps = int(openfile.readline())
	paramsAsDists = eval(openfile.readline())
	randomStart = eval(openfile.readline())
	openfile.close()
	return gridname, stats, pops, keys, indices, nreps, paramsAsDists, randomStart
def readOutfile(outfilename, cosi_build = "cosi_coalescent-2.0/coalescent"):
	""" parses stdout from scipy.optimize.minimize on run samplePoint with random dimensions searched"""
	#print "MUST CONFIG FOR AWS"
	pointParamss, errors = [], []
	paramDict = generateParams()
	keys = paramDict.keys()
	paramfiles, statfiles = [], []
	errorDict = {}
	numIters = 0
	modifications = []

	#first check if the file exists
	if os.path.isfile(outfilename) and sum(1 for line in open(outfilename, 'r')) > 0: #if we have a non-empty file:
		openfile = open(outfilename, 'r')
		line = openfile.readline()
		while line != "START: \n":
			line = openfile.readline() #"START:"
		descentmethod = openfile.readline()
		stepsize = float(openfile.readline())
		pops = eval(openfile.readline())
		stats = eval(openfile.readline())
		keys = eval(openfile.readline())
		numParams = len(keys)
		indices = eval(openfile.readline())
		while " ---------------- \n" not in line:
			line = openfile.readline()
		#for i in range(2):
		#	openfile.readline() #first point redundant info

		while True:
			line = openfile.readline()
			if not line: 
				break
			words = line.split()
			if words[0] == cosi_build:
				numIters +=1 #pass
				paramfilename, statfilename = words[2], words[10]
				paramfiles.append(paramfilename)
				statfiles.append(statfilename)
			if words[0] == "RMS,":
				line = line.strip('RMS, ')
				entries = line.split(": ")
				key, thisComponentErr = eval(entries[0]), float(entries[1])
				if key in errorDict:
					errorDict[key].append(thisComponentErr)
				else:
					errorDict[key] = [thisComponentErr]
			if words[0] == "error:":
				thisError = float(words[1])
				errors.append(thisError)

			if words[0] == "best":
				#print words
				mods = words[1:]
				modstring = ""
				#print "mods: " + str(mods)
				for item in mods:
					modstring += item
				modstring = modstring.replace('|', '\t')

				#words = words.split('|')
				modifications.append(modstring)

			if "success:" in words:
				print line

			if "running" in words:
				thispointParams = readParameterValues(openfile, numParams)
				pointParamss.append(thispointParams)
				if len(thispointParams) != numParams:
					return False

		openfile.close()
		if len(errors) != 0:
			bestindex = errors.index(min(errors))
		#print "Best: " + statfiles[bestindex] + "\t" + paramfiles[bestindex]
			print "Minimum error: " + str(min(errors))
		#assert len(errors) == len(statfiles) and len(statfiles) == len(paramfiles)
			beststat, bestparam, firststat, firstparam = statfiles[bestindex], paramfiles[bestindex], statfiles[0], paramfiles[0]
		
		#Catch truncated runs? 
		if len(errors) == 0:
			return False
		#if len(errors) != len(statfiles) or len(statfiles) != len(errors):
		#	return False
		
		return pointParamss, errors, numIters, errorDict, keys, indices, descentmethod, stepsize, beststat, bestparam, firststat, firstparam, modifications, pops, stats
	else:
		return False
def readIScustomstatfile(statfilename, numPops):
	stats = {}
	openfile = open(statfilename, 'r')
	for ipop in range(1, numPops+1): 
		openfile.readline() #pop label
		stats[('pi', ipop)] = [float(openfile.readline())]
		stats[('sfs', ipop)]  = [float(x) for x in openfile.readline().split()]
		stats[('anc', ipop)]  = [float(x) for x in openfile.readline().split()]
		stats[('r2', ipop)]  = [float(x) for x in openfile.readline().split()]
		stats[('dprime', ipop)]  = [float(x) for x in openfile.readline().split()]
		stats[('pi_var', ipop)] = [float(openfile.readline())]
		stats[('sfs_var', ipop)]  = [float(x) for x in openfile.readline().split()]
		stats[('anc_var', ipop)]  = [float(x) for x in openfile.readline().split()]
		stats[('r2_var', ipop)]  = [float(x) for x in openfile.readline().split()]
		stats[('dprime_var', ipop)]  = [float(x) for x in openfile.readline().split()]
	popPairs = []
	for ipop in range(1, numPops+1):
		for jpop in range(ipop, numPops+1):
			if ipop != jpop: 
				popPairs.append((ipop, jpop))
	for i in range(len(popPairs)):
		line = openfile.readline()
		entries = line.split('\t')
		fst, fst_var = float(entries[1]), float(entries[2])
		stats[('fst', popPairs[i])] = [fst]
		stats[('fst_var', popPairs[i])] = [fst_var]
	openfile.close()
	#print stats
	return stats